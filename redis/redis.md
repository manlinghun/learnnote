# Redis

## 1. 安装

1. 下载安装包 [下载路径](https://redis.io/download/)
2. 上传到服务器 /home/soft并解压
3. 进入解压目录
4. 执行make命令
5. 执行make install命令，默认安装目录为/usr/local/bin
6. 为方便配置文件的修改，可将配置文件复制一份到/usr/local/bin目录
~~~shell
cd /usr/local/bin
mkdir redis-config
cp /home/soft/redis-6.2.3/redis.conf /usr/local/bin/redis-config
cd /usr/local/bin/
./redis-server redis-config/redis.conf
~~~
7. 连接测试
~~~shell
[root@localhost soft]# redis-cli 
127.0.0.1:6379> ping
PONG
127.0.0.1:6379> 
~~~

## 2. redis持久化方式

### 2.1. AOF(Append Only File)

AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。Redis默认情况是不开启AOF的。重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。

AOF是执行完命令后才记录日志的。为什么不先记录日志再执行命令呢？这是因为Redis在向AOF记录日志时，不会先对这些命令进行语法检查，如果先记录日志再执行命令，日志中可能记录了错误的命令，Redis使用日志回复数据时，可能会出错。正是因为执行完命令后才记录日志，所以不会阻塞当前的写操作。但是会存在两个风险：

* 更执行完命令还没记录日志时，宕机了会导致数据丢失
* AOF不会阻塞当前命令，但是可能会阻塞下一个操作。

这两个风险最好的解决方案是折中妙用AOF机制的三种写回策略 appendfsync：

* always，同步写回，每个子命令执行完，都立即将日志写回磁盘。
* everysec，每个命令执行完，只是先把日志写到AOF内存缓冲区，每隔一秒同步到磁盘。
* no：只是先把日志写到AOF内存缓冲区，有操作系统去决定何时写入磁盘。

always同步写回，可以基本保证数据不丢失，no策略则性能高但是数据可能会丢失，一般可以考虑折中选择everysec。

AOF优点：

* 数据保证：我们可以设置fsync策略，一般默认是everysec，也可以设置每次写入追加，所以即使服务死掉了，也最多丢失一秒数据
* 自动缩小：当aof文件大小到达一定程度的时候，后台会自动的去执行aof重写，此过程不会影响主进程，重写完成后，新的写入将会写到新的aof中，旧的就会被删除掉。但是此条如果拿出来对比rdb的话还是没有必要算成优点，只是官网显示成优点而已。

AOF缺点：

* 性能相对较差：它的操作模式决定了它会对redis的性能有所损耗。
* 体积相对更大：尽管是将aof文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。
* 恢复速度更慢：AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。

### 2.2. RDB(Redis Database)

RDB，就是把内存数据以快照的形式保存到磁盘上。和AOF相比，它记录的是某一时刻的数据，并不是操作。RDB持久化，是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中，它是Redis默认的持久化方式。执行完操作后，在指定目录下会生成一个dump.rdb文件，Redis 重启的时候，通过加载dump.rdb文件来恢复数据。

rdb的优点：

* 体积更小：相同的数据量rdb数据比aof的小，因为rdb是紧凑型文件。
* 恢复更快：因为rdb是数据的快照，基本上就是数据的复制，不用重新读取再写入内存。
* 性能更高：父进程在保存rdb时候只需要fork一个子进程，无需父进程的进行其他io操作，也保证了服务器的性能。

rdb的缺点：

* 故障丢失：因为rdb是全量的，我们一般是使用shell脚本实现30分钟或者1小时或者每天对redis进行rdb备份，（注，也可以是用自带的策略），但是最少也要5分钟进行一次的备份，所以当服务死掉后，最少也要丢失5分钟的数据。
* 耐久性差：相对aof的异步策略来说，因为rdb的复制是全量的，即使是fork的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，fork的时间也会延长，导致cpu吃紧，耐久性相对较差。

### 2.3. 如何选择RDB和AOF

如果数据不能丢失，RDB和AOF混用

如果只作为缓存使用，可以承受几分钟的数据丢失的话，可以只使用RDB。

如果只使用AOF，优先使用everysec的写回策略。

## 3. redis回收策略

1. LRU（Least Recently Used）
   
   LRU 策略根据数据最近被访问的时间来判断数据是否被使用。当空间满时，会优先淘汰那些最长时间没被访问的数据。该策略比较简单有效，并且与实际应用场景相符合。例如缓存数据库通常采用 LRU 策略，因为缓存中经常访问的数据不会被淘汰掉。

2. LFU（Least Frequently Used）

    LFU 策略在回收处理时考虑数据的热度，根据多个周期内被访问的次数来淘汰数据。每个键有一个计数的值，表示它在最近一段时间内被访问的次数，周期长度可由用户指定。 LFU 的缺点是需要追踪并更新每个键的访问次数，这会增加计算开销。另外，对于暂时访问较少但在将来可能会被使用的数据，LFU 没有 LRU 的容错性那么高。

3. Random（随机策略）

    随机策略是一种非常基础的回收策略，它根据一个随机数值来淘汰内存中的 key。由于该策略没有考虑数据的使用频率和时间，因此通常用作后备策略，仅在面临极端情况下才会启用。

在 Redis 默认设置下，在服务器的结构体中包含了 maxmemory 和 maxmemory-policy 两个选项。请注意，maxmemory 选项规定 Redis 的最大内存，而 maxmemory-policy 选项则指定满足 maxmemory 时应采取的策略

* volatile-lru —删除最近最少使用(lru)的key，限制为过期的数据(设置expire)
* volatile-ttl —删除即将过期(ttl)的key，限制为过期的数据(设置expire)
* volatile-random — 删除任意的key,限制为过期的数据(设置expire)
* allkeys-lru —删除最近最少使用的key，不考虑是否过期
* allkeys-random — 删除任意的key，不考虑是否过期
* no-enviction — 不删除任何value，只新增当内存已经满载了.

在配置策略时，需要结合实际业务场景来进行调整。maxmemory-policy对于redis实例的经营十分重要，应该根据不同的存储特性和数据对象进行选择，这可以有效提高 Redis 数据库的运行效率。

总结，Redis 回收（淘汰策略）的具体方案根据实际的需求以及使用情况来设定，不同的方案具有不同的优缺点。需要针对实际需求，在平衡内存与性能的前提下，使用最适宜的一种回收策略。

