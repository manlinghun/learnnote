# Redis

## 1. 安装

1. 下载安装包 [下载路径](https://redis.io/download/)
2. 上传到服务器 /home/soft并解压
3. 进入解压目录
4. 执行make命令
5. 执行make install命令，默认安装目录为/usr/local/bin
6. 为方便配置文件的修改，可将配置文件复制一份到/usr/local/bin目录
~~~shell
cd /usr/local/bin
mkdir redis-config
cp /home/soft/redis-6.2.3/redis.conf /usr/local/bin/redis-config
cd /usr/local/bin/
./redis-server redis-config/redis.conf
~~~
7. 连接测试
~~~shell
[root@localhost soft]# redis-cli 
127.0.0.1:6379> ping
PONG
127.0.0.1:6379> 
~~~

## 2. redis持久化方式

  redis持久化主要是RDB和AOF

### 2.1. RDB(Redis Database)

#### 2.1.1. 概念

RDB，就是把内存数据以快照的形式保存到磁盘上。和AOF相比，它记录的是某一时刻的数据，并不是操作。RDB持久化，是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中，它是Redis默认的持久化方式。执行完操作后，在指定目录下会生成一个dump.rdb文件，Redis 重启的时候，通过加载dump.rdb文件来恢复数据。

#### 2.1.2. 配置

redis.conf

~~~conf
    #时间策略
    save 3600 1 # 900 秒内有 1 个 key 发生变化
    save 300 100 # 300 秒内 100 个 key 发生变化
    save 60 10000 # 60 秒内有 10000 个 key 发生变化
    #RDB文件名称
    dbfilename dump.rdb
    #文件保存路径
    dir ./
    #如果持久化出错，主进程是否停止写入
    stop-writes-on-bgsave-error yes
    #是否压缩：redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能
    rdbcompression yes
    #是否检查rdb备份文件的完整性 存储快照后 还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取最大的性能提升，可以关闭此功能
    rdbchecksum yes
~~~


#### 2.1.3. 触发方式

1. 自动触发，即配置文件中配置的save规则
   
   ~~~conf
        save 3600 1 # 900 秒内有 1 个 key 发生变化
        save 300 100 # 300 秒内 100 个 key 发生变化
        save 60 10000 # 60 秒内有 10000 个 key 发生变化
   ~~~

2. 手动执行备份
  
   * save: save时只管保存，其他不管，全部阻塞，手动保存，不建议使用
   * bgsave：redis会在后台异步进行快照操作，快照同时还可以响应客户端情况。
  
   可以通过 lastsave 命令获取最后一次成功生成快照的时间（时间戳）
   ~~~
    127.0.0.1:6379> lastsave
    (integer) 1694940778
   ~~~

3. flushall命令
   
   执行 flushall 命令，也会产生dump.rdb文件，但里面是空的，无意义


#### 2.1.4. 备份恢复

1. 获取rdb文件目录
   * redis.conf文件查看dir配置
   * 执行config get dir命令查看
2. 停止Redis
3. 将需要还原的备份文件复制到第一步得到的路径中
4. 启动Redis


#### 2.1.5. 优缺点

* rdb的优点：

  * 体积更小：相同的数据量rdb数据比aof的小，因为rdb是紧凑型文件。
  * 恢复更快：因为rdb是数据的快照，基本上就是数据的复制，不用重新读取再写入内存。
  * 性能更高：父进程在保存rdb时候只需要fork一个子进程，无需父进程的进行其他io操作，也保证了服务器的性能。

* rdb的缺点：

  * 故障丢失：因为rdb是全量的，我们一般是使用shell脚本实现30分钟或者1小时或者每天对redis进行rdb备份，（注，也可以是用自带的策略），但是最少也要5分钟进行一次的备份，所以当服务死掉后，最少也要丢失5分钟的数据。
  * 耐久性差：相对aof的异步策略来说，因为rdb的复制是全量的，即使是fork的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，fork的时间也会延长，导致cpu吃紧，耐久性相对较差。

### 2.2. AOF(Append Only File)

#### 2.2.1. 概念

AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。Redis默认情况是不开启AOF的。重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。

AOF是执行完命令后才记录日志的。为什么不先记录日志再执行命令呢？这是因为Redis在向AOF记录日志时，不会先对这些命令进行语法检查，如果先记录日志再执行命令，日志中可能记录了错误的命令，Redis使用日志回复数据时，可能会出错。正是因为执行完命令后才记录日志，所以不会阻塞当前的写操作。但是会存在两个风险：

* 更执行完命令还没记录日志时，宕机了会导致数据丢失
* AOF不会阻塞当前命令，但是可能会阻塞下一个操作。

#### 2.2.2. 持久化策略配置

这两个风险最好的解决方案是折中妙用AOF机制的三种写回策略 appendfsync：

* always，同步写回，每个子命令执行完，都立即将日志写回磁盘。
* everysec（默认），每个命令执行完，只是先把日志写到AOF内存缓冲区，每隔一秒同步到磁盘，服务器出现故障，最多只丢失一秒钟内的执行的命令数据。
* no：只是先把日志写到AOF内存缓冲区，有操作系统去决定何时写入磁盘。

always同步写回，可以基本保证数据不丢失，no策略则性能高但是数据可能会丢失，一般可以考虑折中选择everysec。


#### 2.2.3. 重写机制

Redis在长期运行的过程中，aof 文件会越变越长。如果机器宕机重启，“重演”整个 aof 文件会非常耗时，导致长时间 Redis 无法对外提供服务。因此就需要对 aof 文件做一下“瘦身”运动。

#### 2.2.4. 优缺点

* AOF优点：

  * 数据保证：我们可以设置fsync策略，一般默认是everysec，也可以设置每次写入追加，所以即使服务死掉了，也最多丢失一秒数据
  * 自动缩小：当aof文件大小到达一定程度的时候，后台会自动的去执行aof重写，此过程不会影响主进程，重写完成后，新的写入将会写到新的aof中，旧的就会被删除掉。但是此条如果拿出来对比rdb的话还是没有必要算成优点，只是官网显示成优点而已。

* AOF缺点：

  * 性能相对较差：它的操作模式决定了它会对redis的性能有所损耗。
  * 体积相对更大：尽管是将aof文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。
  * 恢复速度更慢：AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。


### 2.3. 如何选择RDB和AOF

如果数据不能丢失，RDB和AOF混用

如果只作为缓存使用，可以承受几分钟的数据丢失的话，可以只使用RDB。

如果只使用AOF，优先使用everysec的写回策略。

## 3. redis回收策略

1. LRU（Least Recently Used）
   
   LRU 策略根据数据最近被访问的时间来判断数据是否被使用。当空间满时，会优先淘汰那些最长时间没被访问的数据。该策略比较简单有效，并且与实际应用场景相符合。例如缓存数据库通常采用 LRU 策略，因为缓存中经常访问的数据不会被淘汰掉。

2. LFU（Least Frequently Used）

    LFU 策略在回收处理时考虑数据的热度，根据多个周期内被访问的次数来淘汰数据。每个键有一个计数的值，表示它在最近一段时间内被访问的次数，周期长度可由用户指定。 LFU 的缺点是需要追踪并更新每个键的访问次数，这会增加计算开销。另外，对于暂时访问较少但在将来可能会被使用的数据，LFU 没有 LRU 的容错性那么高。

3. Random（随机策略）

    随机策略是一种非常基础的回收策略，它根据一个随机数值来淘汰内存中的 key。由于该策略没有考虑数据的使用频率和时间，因此通常用作后备策略，仅在面临极端情况下才会启用。

在 Redis 默认设置下，在服务器的结构体中包含了 maxmemory 和 maxmemory-policy 两个选项。请注意，maxmemory 选项规定 Redis 的最大内存，而 maxmemory-policy 选项则指定满足 maxmemory 时应采取的策略

* volatile-lru —删除最近最少使用(lru)的key，限制为过期的数据(设置expire)
* volatile-ttl —删除即将过期(ttl)的key，限制为过期的数据(设置expire)
* volatile-random — 删除任意的key,限制为过期的数据(设置expire)
* allkeys-lru —删除最近最少使用的key，不考虑是否过期
* allkeys-random — 删除任意的key，不考虑是否过期
* no-enviction — 不删除任何value，只新增当内存已经满载了.

在配置策略时，需要结合实际业务场景来进行调整。maxmemory-policy对于redis实例的经营十分重要，应该根据不同的存储特性和数据对象进行选择，这可以有效提高 Redis 数据库的运行效率。

总结，Redis 回收（淘汰策略）的具体方案根据实际的需求以及使用情况来设定，不同的方案具有不同的优缺点。需要针对实际需求，在平衡内存与性能的前提下，使用最适宜的一种回收策略。


## 4. 主从、哨兵、集群


[Redis集群模式深入解析：主从、哨兵和Cluster的区别与优劣](https://baijiahao.baidu.com/s?id=1763613487831111392&wfr=spider&for=pc)

### 4.1. 主从模式

#### 4.1.1. 概念

主从模式是Redis最基本的集群模式，它实现了数据的复制和读写分离。在主从模式中，有一个主服务器（master）和多个从服务器（slave）。主服务器负责处理写操作，并将数据变化同步给从服务器。从服务器一般只负责处理读操作，并接收主服务器的数据更新。一个主服务器可以有多个从服务器，但一个从服务器只能有一个主服务器。

#### 4.1.2. 优缺点

* 优点

  1. 提高了数据的可靠性，即使主服务器出现故障，也可以通过从服务器恢复数据。
  2. 分担了主服务器的读压力，提高了系统的吞吐量和响应速度。

* 缺点

  1. 不具备自动容错和恢复功能，如果主服务器宕机，需要手动切换一个从服务器为新的主服务器，并通知其他从服务器和客户端。 
  2. 可能存在数据不一致的问题，因为主从复制是异步进行的，如果主服务器在同步过程中出现故障，或者网络延迟导致部分数据未能及时同步到从服务器，就会造成数据丢失或不一致。
  3. 不支持在线扩容，在集群容量达到上限时，需要停止服务才能增加或减少节点。